bootstrap.servers=${BOOTSTRAP_SERVERS}

acks=all
retries=3

security.protocol=SSL

ssl.truststore.location=/mnt/appsrc/kafka/certs/uat-kafka.truststore.java8.p12
ssl.truststore.password=${SSL_TRUSTSTORE_PASSWORD}
ssl.truststore.type=PKCS12

ssl.keystore.location=/mnt/appsrc/kafka/certs/uat-kafka.keystore.java8.p12
ssl.keystore.password=${SSL_KEYSTORE_PASSWORD}
ssl.key.password=${SSL_KEY_PASSWORD}
ssl.keystore.type=PKCS12

ssl.endpoint.identification.algorithm=




==========================================================
1ï¸âƒ£ What should go into secrets?

From your file, these must be secrets:

ssl.truststore.password

ssl.keystore.password

ssl.key.password

(optionally) bootstrap.servers if itâ€™s sensitive

The cert files (.p12) themselves

Weâ€™ll split this into two secrets (best practice):

Kafka credentials (passwords)

Kafka certs (binary files)

2ï¸âƒ£ Create secret for passwords (key-value)
ğŸ“Œ Command
oc create secret generic kafka-producer-secrets \
  --from-literal=SSL_TRUSTSTORE_PASSWORD=xxxxxxx \
  --from-literal=SSL_KEYSTORE_PASSWORD=xxxxxxx \
  --from-literal=SSL_KEY_PASSWORD=xxxxxx


âœ… This creates a secret with env-friendly keys

Verify:

oc get secret kafka-producer-secrets -o yaml

3ï¸âƒ£ Create secret for Kafka cert files (binary)

Your files:

uat-kafka.truststore.java8.p12
uat-kafka.keystore.java8.p12

ğŸ“Œ Command
oc create secret generic kafka-producer-certs \
  --from-file=uat-kafka.truststore.java8.p12 \
  --from-file=uat-kafka.keystore.java8.p12


Verify:

oc describe secret kafka-producer-certs

4ï¸âƒ£ Mount cert secret into the pod

Mount it exactly where your config expects it:

volumeMounts:
  - name: kafka-certs
    mountPath: /mnt/appsrc/kafka/certs
    readOnly: true

volumes:
  - name: kafka-certs
    secret:
      secretName: kafka-producer-certs


ğŸ“Œ Result inside pod:

/mnt/appsrc/kafka/certs/
 â”œâ”€â”€ uat-kafka.truststore.java8.p12
 â””â”€â”€ uat-kafka.keystore.java8.p12

5ï¸âƒ£ Inject passwords as environment variables
env:
  - name: SSL_TRUSTSTORE_PASSWORD
    valueFrom:
      secretKeyRef:
        name: kafka-producer-secrets
        key: SSL_TRUSTSTORE_PASSWORD

  - name: SSL_KEYSTORE_PASSWORD
    valueFrom:
      secretKeyRef:
        name: kafka-producer-secrets
        key: SSL_KEYSTORE_PASSWORD

  - name: SSL_KEY_PASSWORD
    valueFrom:
      secretKeyRef:
        name: kafka-producer-secrets
        key: SSL_KEY_PASSWORD

6ï¸âƒ£ Update producer_config.properties

Replace hardcoded passwords with env references.

âœ… Recommended version
bootstrap.servers=${BOOTSTRAP_SERVERS}

acks=all
retries=3

security.protocol=SSL

ssl.truststore.location=/mnt/appsrc/kafka/certs/uat-kafka.truststore.java8.p12
ssl.truststore.password=${SSL_TRUSTSTORE_PASSWORD}
ssl.truststore.type=PKCS12

ssl.keystore.location=/mnt/appsrc/kafka/certs/uat-kafka.keystore.java8.p12
ssl.keystore.password=${SSL_KEYSTORE_PASSWORD}
ssl.key.password=${SSL_KEY_PASSWORD}
ssl.keystore.type=PKCS12

ssl.endpoint.identification.algorithm=


âš ï¸ Your app must support env substitution (most Java/Kafka apps do).
If not â†’ weâ€™ll template it at startup (tell me).

7ï¸âƒ£ (Optional but clean) Store config file itself as a secret

If you want zero config baked into image:

oc create secret generic kafka-producer-config \
  --from-file=producer_config.properties


Mount it:

volumeMounts:
  - name: kafka-config
    mountPath: /mnt/appsrc/kafka/config
    readOnly: true

8ï¸âƒ£ Pod restart behavior (important)

âœ… Secrets persist across pod restarts
âœ… No need to recreate them
âŒ If secret value changes â†’ restart pod required

Restart safely:

oc rollout restart deployment <deployment-name>

9ï¸âƒ£ Quick sanity check inside pod
oc rsh <pod-name>

ls /mnt/appsrc/kafka/certs
env | grep SSL_

âœ… Best-practice summary

âœ” No passwords in Git
âœ” Certs managed by OpenShift
âœ” Pod restart safe
âœ” CI/CD friendly
âœ” Security audit friendly



=====================================================================

Perfect ğŸ‘ since this is OpenShift (oc), hereâ€™s the most correct, OpenShift-native, scanner-safe way â€” no Python, no code changes.

Iâ€™ll keep it tight and practical.

âœ… OpenShift-only solution (no Python, no hardcoded secrets)
What weâ€™ll use

Secret â†’ for passwords

ConfigMap â†’ for JSON template

envsubst â†’ to render JSON at pod startup

This is exactly what auditors expect on OpenShift.

1ï¸âƒ£ Create JSON template (SAFE)
drive.json.template
{
  "type": "MariaDB",
  "userName": "drive",
  "userPassword": "${DB_PASSWORD}",
  "keystorePassword": "${KEYSTORE_PASSWORD}"
}


âœ” No secrets
âœ” Wonâ€™t be flagged by SCA

2ï¸âƒ£ Create OpenShift Secret
oc create secret generic drive-secrets \
  --from-literal=DB_PASSWORD=******** \
  --from-literal=KEYSTORE_PASSWORD=********

3ï¸âƒ£ Create OpenShift ConfigMap for template
oc create configmap drive-config-template \
  --from-file=drive.json.template

4ï¸âƒ£ Deployment YAML (OpenShift-native)
ğŸ”¹ Environment variables from Secret
env:
  - name: DB_PASSWORD
    valueFrom:
      secretKeyRef:
        name: drive-secrets
        key: DB_PASSWORD

  - name: KEYSTORE_PASSWORD
    valueFrom:
      secretKeyRef:
        name: drive-secrets
        key: KEYSTORE_PASSWORD

ğŸ”¹ Mount JSON template
volumeMounts:
  - name: drive-config
    mountPath: /config
    readOnly: true

volumes:
  - name: drive-config
    configMap:
      name: drive-config-template

5ï¸âƒ£ Generate real JSON at pod startup
ğŸ”¹ Command override
command: ["/bin/sh", "-c"]
args:
  - |
    envsubst < /config/drive.json.template > /config/drive.json
    exec /usr/bin/start-app


ğŸ“Œ Replace /usr/bin/start-app with your real start command.

6ï¸âƒ£ Result inside pod (proof)
oc rsh <pod-name>
cat /config/drive.json


Youâ€™ll see:

{
  "type": "MariaDB",
  "userName": "drive",
  "userPassword": "******",
  "keystorePassword": "******"
}


âœ” Exists only at runtime
âœ” Never stored in Git
âœ” Never hardcoded

ğŸ›¡ Why OpenText SCA will clear this

âŒ No password literals in code

âŒ No static secrets in JSON

âœ… Secrets managed by OpenShift

âœ… Runtime injection only

This matches exactly their recommendation:

â€œPasswords should be managed in an external source.â€

ğŸ§¾ One-liner for security report

You can paste this:

Hardcoded passwords were removed from JSON configuration files. Sensitive values are managed using OpenShift Secrets and injected into the application at runtime via environment variable substitution. No credentials are stored in source-controlled artifacts.

â­ OpenShift best-practice tip

If you ever rotate secrets:

oc rollout restart deployment <name>


No code changes needed âœ”
