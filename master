bootstrap.servers=${BOOTSTRAP_SERVERS}

acks=all
retries=3

security.protocol=SSL

ssl.truststore.location=/mnt/appsrc/kafka/certs/uat-kafka.truststore.java8.p12
ssl.truststore.password=${SSL_TRUSTSTORE_PASSWORD}
ssl.truststore.type=PKCS12

ssl.keystore.location=/mnt/appsrc/kafka/certs/uat-kafka.keystore.java8.p12
ssl.keystore.password=${SSL_KEYSTORE_PASSWORD}
ssl.key.password=${SSL_KEY_PASSWORD}
ssl.keystore.type=PKCS12

ssl.endpoint.identification.algorithm=




==========================================================
1Ô∏è‚É£ What should go into secrets?

From your file, these must be secrets:

ssl.truststore.password

ssl.keystore.password

ssl.key.password

(optionally) bootstrap.servers if it‚Äôs sensitive

The cert files (.p12) themselves

We‚Äôll split this into two secrets (best practice):

Kafka credentials (passwords)

Kafka certs (binary files)

2Ô∏è‚É£ Create secret for passwords (key-value)
üìå Command
oc create secret generic kafka-producer-secrets \
  --from-literal=SSL_TRUSTSTORE_PASSWORD=xxxxxxx \
  --from-literal=SSL_KEYSTORE_PASSWORD=xxxxxxx \
  --from-literal=SSL_KEY_PASSWORD=xxxxxx


‚úÖ This creates a secret with env-friendly keys

Verify:

oc get secret kafka-producer-secrets -o yaml

3Ô∏è‚É£ Create secret for Kafka cert files (binary)

Your files:

uat-kafka.truststore.java8.p12
uat-kafka.keystore.java8.p12

üìå Command
oc create secret generic kafka-producer-certs \
  --from-file=uat-kafka.truststore.java8.p12 \
  --from-file=uat-kafka.keystore.java8.p12


Verify:

oc describe secret kafka-producer-certs

4Ô∏è‚É£ Mount cert secret into the pod

Mount it exactly where your config expects it:

volumeMounts:
  - name: kafka-certs
    mountPath: /mnt/appsrc/kafka/certs
    readOnly: true

volumes:
  - name: kafka-certs
    secret:
      secretName: kafka-producer-certs


üìå Result inside pod:

/mnt/appsrc/kafka/certs/
 ‚îú‚îÄ‚îÄ uat-kafka.truststore.java8.p12
 ‚îî‚îÄ‚îÄ uat-kafka.keystore.java8.p12

5Ô∏è‚É£ Inject passwords as environment variables
env:
  - name: SSL_TRUSTSTORE_PASSWORD
    valueFrom:
      secretKeyRef:
        name: kafka-producer-secrets
        key: SSL_TRUSTSTORE_PASSWORD

  - name: SSL_KEYSTORE_PASSWORD
    valueFrom:
      secretKeyRef:
        name: kafka-producer-secrets
        key: SSL_KEYSTORE_PASSWORD

  - name: SSL_KEY_PASSWORD
    valueFrom:
      secretKeyRef:
        name: kafka-producer-secrets
        key: SSL_KEY_PASSWORD

6Ô∏è‚É£ Update producer_config.properties

Replace hardcoded passwords with env references.

‚úÖ Recommended version
bootstrap.servers=${BOOTSTRAP_SERVERS}

acks=all
retries=3

security.protocol=SSL

ssl.truststore.location=/mnt/appsrc/kafka/certs/uat-kafka.truststore.java8.p12
ssl.truststore.password=${SSL_TRUSTSTORE_PASSWORD}
ssl.truststore.type=PKCS12

ssl.keystore.location=/mnt/appsrc/kafka/certs/uat-kafka.keystore.java8.p12
ssl.keystore.password=${SSL_KEYSTORE_PASSWORD}
ssl.key.password=${SSL_KEY_PASSWORD}
ssl.keystore.type=PKCS12

ssl.endpoint.identification.algorithm=


‚ö†Ô∏è Your app must support env substitution (most Java/Kafka apps do).
If not ‚Üí we‚Äôll template it at startup (tell me).

7Ô∏è‚É£ (Optional but clean) Store config file itself as a secret

If you want zero config baked into image:

oc create secret generic kafka-producer-config \
  --from-file=producer_config.properties


Mount it:

volumeMounts:
  - name: kafka-config
    mountPath: /mnt/appsrc/kafka/config
    readOnly: true

8Ô∏è‚É£ Pod restart behavior (important)

‚úÖ Secrets persist across pod restarts
‚úÖ No need to recreate them
‚ùå If secret value changes ‚Üí restart pod required

Restart safely:

oc rollout restart deployment <deployment-name>

9Ô∏è‚É£ Quick sanity check inside pod
oc rsh <pod-name>

ls /mnt/appsrc/kafka/certs
env | grep SSL_

‚úÖ Best-practice summary

‚úî No passwords in Git
‚úî Certs managed by OpenShift
‚úî Pod restart safe
‚úî CI/CD friendly
‚úî Security audit friendly
